@ Spring IoC
-> Inversion of Control 로써 제어의 역행이라는 뜻을 가지고 있음
-> 프로그램을 구동하는데 필요한 객체에 대한 생성, 변경 등의 관리를
프로그램을 개발하는 사람이 아닌 프로그램을 구동하는데 컨테이너에서 직접 관리하는것을 말함
-> 스프링은 IoC 구조를 통해 구동 시 필요한 객체의 생성부터 생명주기까지
해당 객체에 대한 관리를 직접 수행 하게 됨

@ IoC 컨테이너의 역할
-> 객체의 생명주기와 의존성을 관리함
	- 생명 주기 : 생성 - >초기화 -> 사용 -> 소멸
	- 의존성 : 개발자가 직접 객체를 생성할 수 있지만 해당 권한을 컨테이너에
	맡김으로서 소스코드 구현의 시간을 단축할 수 있음


@ Spring DI
-> Dependency Injection 이란 IoC 구현의 핵심기술로, 사용하는 객체를 직접
생성하여 만드는 것이 아니라 컨테이너가 빈의 설정 정보를 읽어와 해당 객체에 연결하는 
것을 말함
-> 이렇게 의존성을 주입받게 되면 이후 해당 객체를 수정해야 할 상황이 발생했을 때
소스 코드의 수정을 최소화 할 수 있음
* 소스코드에서 new를 이용하여 객체를 만들거나 데이터를 직접적으로 작성하면
객체가 변경되거나 수정해야 할때 또 다시 코드 수정을 해야 하고 재컴파일 해야 하는
문제가 발생함
DI를 이용하면 소스코드를 재수정하고, 재컴파일 하는 경우를 줄일 수 있음

## DI의 장점 ##
-> 개발자가 작성해야 할 코드가 단순해짐
-> 각 객체간의 종속 관계(결합도)를 해소할 수 있음

## 객체간의 종속관계 (결합도) ##
-> 한클래스에서 필드 객체를 생성할 때 발생하는 두 객체간의 관계를 말하며,
각 객체간의 내용이 수정될 경우 영향을 미치는 정도를 뜻함
-> 예를 들어 A Class에서 B Class를 생성할 경우, 만약 B Class의 생성자의 매개변수가
변경되거나 제공하는 메소드가 변경될 경우 이를 사용하는 A Class의 일부 정보도
필히 수정해야 하는 상황이 발생하게 되는데 이를 '두 객체간 종속관계(결합도)가
강하다' 라고 표현함

* 결합도가 낮을수록 좋은 코드


resources 폴더에 

Spring Bean Definition File 을 만들어준다. 이름 sampleContext.xml

finish 하지말고, next 해서 beans를 선택해준다.

beans를 선택하고 4.3.xsd를 또 선택해준다.


@ DI의 종류
-> 메소드를 통한 의존성 주입
	- 의존성을 입력받는 일반 메소드를 만들고 이를 통해 의존성을 주입함
	- 팩토리 패턴을 사용하는 방식

-> Setter 메소드를 통한 의존성 주입
	- 의존성을 주입받는 Setter 메소드를 만들고, 이를 통해 의존성을 주입

-> 생성자를 통한 의존성 주입
	- 필요한 의존성을 포함하는 클래스에 생성자를 만들고, 이를 통해
	의존성을 주입

## Setter 메소드를 통한 의존성 주입 ##
-> Setter 메소드를 통해 의존관계가 있는 Bean을 주입하려면 <property> 태그를 사요함

* Bean이란?	-> 쉽게 생각하면 자바객체를 Bean 객체라고 함
		-> 스프링 컨테이너에 의해 만들어진 객체를 Bean이라고 함

# XML 선언 방법 #
<bean id="객체이름" class="클래스 풀네임"/>
	<property name="name" value="000"/>
	<property name="name" ref="000" />
</bean>

-> name 속성은 class에서 선언한 필드 변수의 이름을 사용
-> value 속성은 단순 값 또는 Bean이 아닌 객체를 주입할 때 사용
-> ref 속성을 사용하면 Bean id 를 이요해 주입할 Bean을 찾음


## 생성자를 통한 의존성 주입 ##
-> Constructor 를 통해 의존관계가 있는 Bean을 주입하려면 <constructor-arg> 태그를 사용함

# XML 선언방법 ##
<bean id="불러올객체" class="클래스 풀네임" >
	<constructor-arg index="0" value="000"/>
	<contsructor-arg name="000" ref="000" />
</bean>

-> Constructor 주입방식은 생성자의 파라미터를 이용하기 때문에
한번에 여러개의 객체를 주입할 수 있음
-> 필드 선언 순서에 따라 index 속성을 통해서도 접근이 가능함
-> <constructor-arg> 태그에서 index 나 name을 생략하면 해당 클래스의
	생성자가 매개변수 순서에 따라 값이 처리 됨


@ 스프링 컨테이너의 종류
-> 스프링에서는 BeanFactory 와 이를 상속한 ApplicationContext라는 두 가지 유형의
컨테이너를 제공하고 있음
-> 먼저 BeanFactory는 스프링 설정 파일에 등록된 <bean> 객체를 생성하고 관리하는
가장 기본적인 컨테이너 기능만 제공함
	(실제로 우리가 BeanFactory 컨테이너를 사용하지는 않음)
-> ApplicationContext는 BeanFactory 를 상속 받았으며 <bean> 객체 관리 기능 외에도
트랜잭션 관리나 메시지 기반의 다국어 처리 등 다양한 기능을 제공하고 있음
-> 또한 웹 애플리케이션 개발도 지원하므로 대부분 스프링 프로젝트는
ApplicationContext유형의 컨테이너를 이용함

* 실제로 ApplicationContext의 구현 클래스는 너무나도 다양함
(너무 많기 대문에 우리는 모두 기억할 필요 없고 2가지 용도만 기억 하면 됨 - 아래 참조)

## GenericXmlApplicationContext ##
-> 파일 시스템이나 클래스 경로에 있는 XML 설정 파일을 로딩하여 구동하는 컨테이너

## XmlWebApplicationContext ##
-> 웹 기반의 스프링 애플리케이션을 개발할 때 사용하는 컨테이너
-> 웹 애플리케이션 개발에서 사용되며, 우리가 직접 생성하진 않음


@ 스프링 XML 설정 태그

## <beans> ##
-> 스프링 컨테이너는 <bean> 저장소에 해당하는 XML 설정 파일을 참조하여
<bean> 들의 생명주기를 관리하고 여러가지 서비스를 제공하고 있음


## <import> 앨리먼트 ##
-> 스프링은 설정 파일(XML) 하나에 우리가 만든 모든 클래스를 <bean>으로 등록하고
관리할 수 있지만 너무 많은 코드가 하나의 XML 파일에 등록되면 코드 길이가 길어지고
관리가 어려워짐
-> 이때 , XML 파일을 여러개로 나누어 설정 할 수 있음


## scope 속성 ##
-> 프로그램을 개발하다보면 개발자도 모르는 사이에 수많은 객체가 생성 됨
-> 이 중에서 하나마 생성되어도 상관없은 객체들이 있음
-> scope속성을 이용하면 객체를 singleton 형태로 만들것인지 아니면
계속적으로 새롭게 생성할 것인지를 설정할 수 있음
	- 기본값은 싱글톤, 매번 새롭게 만들때에는 "prototype" 값을 주면 됨

@ 컬렉션 (Collection)객체 설정
-> 스프링을 개발하다 보면 배열이나 List같은 컬렉션 객체를 이용하여 데이터를 
담을 수 있어야 함
-> 이때, 스프링에서는 컬렉션 매핑과 관련된 엘리먼트를 지원함

## List 타입 매핑 ##
-> 배열 객체나 java.util.List 타입의 컬렉션 객체는 <list> 태그를 사용하여 설정함
-> 우선적으로 컬렉션을 멤버변수로 가지는 CollectionBean클래스를 작성하여
사용해야 함

## Set 타입 매핑 ##
-> 중복 값을허용하지 않는 집합 객체를 사용할때에는 Set을 사용하게 되는데
스프링에서는 Set 컬렉션과의 매핑도 지원함

## Map 타입 매핑 ##
-> 특정 key로 데이터를 등록하고 사용하는 Map 컬렉션과의 매핑을 지원함

@ DI 어노테이션 방식
-> 대부분 프레임워크가 그렇듯이 스프링 프레임 워크 역시 XML 설정이 매우 중요함
-> 하지만 반대적으로 XML 파일의 과도한 설정을 하게 되면 내용이 굉장히 
많아지게 되고 관리하기 부담스러워 짐
-> 따라서 대부분의 프레임워크는 XML 방식이외에도 어노테이션 방식을 이용한
DI설정을 지원하고 있음

## Context 네임 스페이스 추가 ##
-> 어노테이션 설정을 추가하려면 <beans> 에 Context관련 네임스페이스와 스키마 문서의
위치를 등록 해야함


## 컴포넌트 스캔(component-scan) 설정 ##
-> 스프링 설정 파일에 애플리케이션에서 사용할 객체들을 <bean> 등록하지 않고
자동적으로 생성하려면 <context:component-scan/> 이라는 앨리먼트를 정의해야함
-> 이 설정을 추가하면 스프링 컨테이너는 클래스 패스에 있는 클래스들을 스캔하여
@Component가 설정된 클래스들을 자동으로 객체 생성함
-> <context:component-scan> 엘리먼트의 base-package 속성값을
"org.kh.spring" 형태로 지정하면 org.kh.spring 으로 시작하는 모든 패키지를 스캔
대상으로 포함함



xml 방식
<bean id="computer" class="...."/>

어노테이션 방식
해당 클래스의 @Component("computer") 를 명시
xml 에서는 <context:component-scan> 을 사용해 추가.

<context:component-scan base-package="org.kh.test.ano"/>

org.kh.text.ano안에있는 어노테이션이 추가 된 모든 객체들을 생성해주겠다.

어노테이션 방식의 장점

객체 생성시점을 정할수 있음
1. 서버 시작과 동시에 생성
	- servlet-context.xml 에 스캔코드를 등록
2. 서블릿 호출시 생성	
	- 별도의 xml 파일에 스캔 코드를 등록
	- 이후 GenericXmlApplicationContext를 읽어 들임

## @Component##
-> scan 설정을 헸다면 스프링 설정파일에 클래스들을 일일이 <bean> 태그를 이용하여
등록할 필요가 없어짐
-> 클래스 선언부 위에 @Component 어노테이션만 추가하면 해당 객체를 만들겠다는 의미가 됨


@ 의존석 주입 설정
-> 스프링에서 의존성 주입을 지원하는 어노테이션으로는 @Autowired,
@Inject, @Qualifier, @Resource 가 있음

## @Autowired ##
-> 주로 변수 위에 설정하여 해당 타입의 객체를 찾아서 자동으로 할당함

## @Qualifier ##
-> 특정 객체의 이름을 이용하여 의존성 주입할 때 사용

## @Inject ##
-> @Autowired와 동일한 기능을 지원함(차이점은 Autowired는 스프링 전용, Inject는 자바전용)

## @Resource ##
-> @Autowired와 @Qulifier의 기능을 결합한 어노테이션














